// Code generated by xgb2code DO NOT EDIT.

package {{.PackageName}}

import (
	"fmt"
	"math"
)

func {{.FuncName}}(data []*float32, predMargin bool) float32 {
    r, _ := {{.FuncName}}MultiClass(data, predMargin)
    return r
}

func {{.FuncName}}MultiClass(data []*float32, predMargin bool) (float32, int) {
    // initialize sums array to base_score
	sums := make([]float32, {{or .NumClasses 1}})
	for i := range sums {
	    sums[i] = {{.BaseScore}}
	}
{{range .TreeFunctions }}
	sums[{{.Class}}] += {{.Name}}(data)
	fmt.Println(sums)
{{- end}}

	if len(sums) > 1 {
	    // multi-class classification
	    var maxClass int
	    var m float32
	    for i, sm := range softmax(sums) {
	        if sm > m {
	            m = sm
	            maxClass = i
            }
        }
	    return m, maxClass
	}

	// binary classification (sigmoid)
	class := 0
	if sums[0] > 0 {
	    class = 1
	}
	return 1.0 / float32(1.0 + math.Exp(float64(-sums[0]))), class
}
{{range .TreeFunctions}}
func {{.Name}}(data []*float32) float32 {
	var sum float32
{{.Code}}
	return sum
}
{{end}}

func softmax(x []float32) []float32 {
    size := len(x)
    result := make([]float32, size)
    max := x[0]
    for _, v := range x {
        if (v > max) {
            max = v
        }
    }
    sum := float32(0.0)
    for i := 0; i < size; i++ {
        result[i] = float32(math.Exp(float64(x[i] - max)))
        sum += result[i]
    }
    for i := 0; i < size; i++ {
        result[i] /= sum
    }
    return result
}

// softmaxInverse takes a 2D slice of softmax probabilities and returns logits.
func softmaxInverse(probs []float32) []float32 {
	logits := make([]float32, len(probs))

    // Compute log of each probability
    for j, p := range probs {
        logits[j] = float32(math.Log(float64(p)))
    }

    // Find max logit value in the row for stability adjustment
    maxLogit := logits[0]
    for _, logit := range logits {
        if logit > maxLogit {
            maxLogit = logit
        }
    }

    // Subtract max logit from each logit for numerical stability
    for j := range logits {
        logits[j] -= maxLogit
    }
	return logits
}